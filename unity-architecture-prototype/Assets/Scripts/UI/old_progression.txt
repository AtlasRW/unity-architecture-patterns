using System;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

[DefaultExecutionOrder(100)]
public class ProgressionManagerUI : MonoBehaviour
{
    public RectTransform progressionContainer;
    public RectTransform currentProgression;
    public RectTransform waveMarker;
    public RectTransform blockMarker;
    public RectTransform progressTrail;
    
    public RectTransform blockContainer;
    public RectTransform waveContainer;

    private float _containerHeight;
    private float _progressIncrement;
    private float _waveIncrement;
    private float _blockIncrement;
    private int _numberOfBlocks;

    public Color defaultColor;
    public Color progressedColor;

    private List<RectTransform> _blockMarkers = new();
    private List<RectTransform> _waveMarkers = new();
    private BlockProgressData[] _blocks;
    
    private EnemyManager _enemyManager;
    private float _currentMarketHeight = 0;
    private int _currentBlockIndex = 0;
    private int _currentWaveIndex = 0;

    private void OnEnable()
    {
        currentProgression.GetComponent<Image>().color = progressedColor;
        progressTrail.GetComponent<Image>().color = progressedColor;
        
        _containerHeight = progressionContainer.rect.height;
        
        // get total number of blocks
        _enemyManager = FindObjectOfType<EnemyManager>();

        if (_enemyManager == null) return;
        
        _numberOfBlocks = _enemyManager.enemySpawnRound.enemySpawnBlocks.Count;
        _blockIncrement = _containerHeight / _numberOfBlocks;
        
        _blocks = new BlockProgressData[_numberOfBlocks];

        // Initialization Loop.
        for (var i = 0; i < _numberOfBlocks; i++)
        {
            var newBlock = new BlockProgressData();
            newBlock.waves = _enemyManager.enemySpawnRound.enemySpawnBlocks[i].spawnWaves.Count;
            newBlock.enemyWaveCount = new int[newBlock.waves];
            _blocks[i] = newBlock;
        }

        var lastBlockCount = 0;
        for(var i = 0; i < _numberOfBlocks; i++)
        {
            var block = _enemyManager.enemySpawnRound.enemySpawnBlocks[i];
            var data = new BlockProgressData();

            #region Waves
            
            // var numberOfWaves = block.spawnWaves.Count;
            // data.enemyWaveCount = new int[numberOfWaves];
            // var lastWaveCount = 0;
            // var waveIncrement = _blockIncrement / numberOfWaves;
            //
            // for (var j = 0; j < numberOfWaves; j++)
            // {
            //     var thisWaveCount =  block.spawnWaves[j].TotalEnemyCount() + lastWaveCount + lastBlockCount;
            //     lastWaveCount = thisWaveCount;
            //     
            //     var waveMarkerInstance = Instantiate(waveMarker, waveContainer);
            //     var waveMarkerHeight = waveIncrement * (j + 1) + i * _blockIncrement;
            //     waveMarkerInstance.anchoredPosition = new Vector2(0, waveMarkerHeight);
            //     waveMarkerInstance.gameObject.SetActive(true);
            //     
            //     var waveAmountReached = thisWaveCount <= _enemyManager.totalEnemiesKilled;
            //
            //     waveMarkerInstance.GetComponent<Image>().color = waveAmountReached ? progressedColor : defaultColor;
            //     data.waveMarkers.Add(waveMarkerInstance);
            //     
            //     data.enemyWaveCount[j] = thisWaveCount;
            // }
            // _blocks[i] = data;
            
            #endregion
                        
            data.enemyBlockCount = block.TotalEnemyCount() + lastBlockCount;
            lastBlockCount = data.enemyBlockCount;
            
            // We also want to instantiate a block marker for each block.
            var blockMarkerInstance = Instantiate(blockMarker, blockContainer);
            data.blockHeight = _blockIncrement * (i + 1);
            blockMarkerInstance.anchoredPosition = new Vector2(0,  data.blockHeight);
            blockMarkerInstance.gameObject.SetActive(true);
            blockMarkerInstance.GetComponentInChildren<TextMeshProUGUI>().text = $"{i + 1}";
            
            var blockAmountReached = data.enemyBlockCount <= _enemyManager.totalEnemiesKilled;
            blockMarkerInstance.GetComponent<Image>().color = blockAmountReached ? progressedColor : defaultColor;
            _blockMarkers.Add(blockMarkerInstance);
            _blocks[i] = data;
        }
        
        blockMarker.gameObject.SetActive(false);
        waveMarker.gameObject.SetActive(false);
        
        
        _progressIncrement = _blockIncrement / _blocks[0].enemyBlockCount;

        if (_currentBlockIndex < _blockMarkers.Count)
        {
            _currentMarketHeight = _blockMarkers[_currentBlockIndex].anchoredPosition.y;
        }
        else
        {
            _currentMarketHeight = _blockMarkers[^1].anchoredPosition.y;
        }
        
        
        
        currentProgression.gameObject.SetActive(true);
        progressTrail.gameObject.SetActive(true);
        
        var snapHeight = _blockMarkers[_currentBlockIndex].anchoredPosition.y;
        currentProgression.anchoredPosition = new Vector2(0, snapHeight);
        progressTrail.sizeDelta = new Vector2(progressTrail.sizeDelta.x, snapHeight);
        
    }
    private void OnDisable()
    {
        foreach(var blockData in _blocks)
        {
            foreach (var marker in blockData.waveMarkers)
            {
                Destroy(marker.gameObject);
            }
        }
        
        foreach (var marker in _blockMarkers)
        {
            Destroy(marker.gameObject);
        }
        _blockMarkers.Clear();
        
        progressTrail.sizeDelta = new Vector2(progressTrail.sizeDelta.x, 0);
        progressTrail.gameObject.SetActive(false);
        
        currentProgression.anchoredPosition = new Vector2(0, 0);
        currentProgression.gameObject.SetActive(false);

    }

    // Update is called once per frame
    void Update()
    {
        var currentProgressionHeight = Mathf.Lerp(currentProgression.anchoredPosition.y, _progressIncrement * _enemyManager.totalEnemiesKilled, Time.deltaTime); 
        currentProgression.anchoredPosition = new Vector2(0, currentProgressionHeight);
        progressTrail.sizeDelta = new Vector2(progressTrail.sizeDelta.x, currentProgressionHeight);
        
        // check if the currentProgressionHeight is greater than the current block marker.
        if (_enemyManager.totalEnemiesKilled >= _blocks[_currentBlockIndex].enemyBlockCount)
        {
            _blockMarkers[_currentBlockIndex].GetComponent<Image>().color = progressedColor;
            _currentWaveIndex = 0;
            if (_currentBlockIndex + 1 < _blocks.Length)
            {
                _currentBlockIndex++;
            }
            _progressIncrement = _blockIncrement / _blocks[_currentBlockIndex].enemyBlockCount - _blocks[_currentBlockIndex - 1].enemyBlockCount;
            var snapHeight = _blockMarkers[_currentBlockIndex].anchoredPosition.y;
            currentProgression.anchoredPosition = new Vector2(0, snapHeight);
            progressTrail.sizeDelta = new Vector2(progressTrail.sizeDelta.x, snapHeight);
        }
        
        // // check if we've hit a wave marker milestone.
        // if(_enemyManager.totalEnemiesKilled >= _blocks[_currentBlockIndex].enemyWaveCount[_currentWaveIndex])
        // {
        //     _blocks[_currentBlockIndex].waveMarkers[_currentWaveIndex].GetComponent<Image>().color = progressedColor;
        //     _currentWaveIndex++;
        // }


    }

    [Serializable]
    public class BlockProgressData
    {
        public float blockHeight;
        public int enemyBlockCount;
        public int waves;
        public int[] enemyWaveCount;
        public List<RectTransform> waveMarkers = new();


    }
}
